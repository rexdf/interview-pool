<!DOCTYPE html>
<html>

<head>
    <title></title>
</head>

<body>
    <p>JS中使用typeof可以得到哪些类型 （JS类型）</p>
    <p>object string number boolean symbol function undefined</p>

    <p>=== 和 == 的区别 （强制类型转换）</p>

    <p>Js中有哪些内置函数 （数据封装类函数）</p>
    <p>Number String Boolean Function Object Regexp Error Array Date</p>

    <p>JS变量按存储方式区分有哪些类型，并描述其特点</p>
    <p>值类型（栈区） 引用类型（堆区）</p>

    <p>如何理解JSON</p>
    <p>JSON.parse() JSON.stringify()，一个js对象</p>

    <p>如何准确判断一个变量是数组</p>
    <p>Object.prototype.toString.call(xx) === '[object Array]'</p>

    <p>写一个原型链继承的例子</p>
    <script type="text/javascript">
    	function Parent (name) {
    		this.name = name || 'parent'
    	}
    	//原型链继承
    	function Child () {}
    	var child = new Child()
    	child = new Parent()

    	// apply call 继承 
    	function Child () {
    		Parent.apply(this)
    	}
    </script>

    <p>描述new一个对象的过程</p>
    <p></p>

    <p>zepto（或其他框架）源码中如何使用原型链</p>

    <p>window.onload 和 DOMContentLoaded的区别（浏览器渲染过程）</p>

    <p>用JS创建10个a标签，点击弹出对应的序号（作用域）</p>

    <p>简述如何实现一个模块加载器，实现一个类似requireJs的功能（js模块化）</p>

    <p>实现数组的随机排序（js基础算法）</p>

    <script type="text/javascript">
    	// 用JS创建10个a标签，点击弹出对应的序号（作用域
    function createUl() {
        var ul = document.createElement('ul')
        var liTag = ''
        for (var i = 0; i < 10; i++) {
            liTag += '<li>' + i + '</li>'
        }
        ul.innerHTML = liTag
        document.body.appendChild(ul)
        ul.addEventListener('click', function(e) {
            if (e.target.nodeName === 'LI') {
                alert(e.target.innerText)
            }
        }, true)
    }
    createUl()
    </script>

    <p>前端实现跨域的几种方式</p>
    <ul>
        <li>JSONP</li>
        <li>document.domain + iframe (仅限主域相同，子域不同)</li>
        <li>window.name + iframe（iframe.contentWindow.name, 最多支持2M数据）</li>
        <li>location.hash + iframe（通过中间页来完成跨域，不用域之间通过hash值单向通信，同域之间可以通过js访问）</li>
        <li>postMessage + iframe（用于多页面，多窗口，以及嵌套iframe的消息传递）</li>
        <li>后端CORS（Access-Control-Allow-Origin）</li>
        <li>Nginx 反向代理跨域</li>
        <li>nodejs中间件代理 http-proxy-middleware中间件 或者 webpack-dev-server 配置devServer.proxy</li>
        <li>websocket协议跨域, 全双工通信，同事允许跨域通信</li>
    </ul>

    <p>前端中的事件流</p>
    <ul>
        <li>事件捕获阶段</li>
        <li>目标时间阶段</li>
        <li>事件冒泡</li>
    </ul>

    <p>JS 中的原型链是什么</p>
    <ul>
        <li>
            function P () {} var p = new P()
            p.__proto__ === P.prototype
            实例对象的__proto__指向他的构造函数的prototype
        </li>
    </ul>

    <p>有一个长度为100的数组，请以优雅的方式求出该数组的前10个元素之和</p>
    <ul>
        <li>arr.length = 10 再reduce求和</li>
    </ul>

    <p>xss和csrf分别是什么</p>
    <ul>
        <li>xss 跨站脚本攻击，用户输入恶意代码到网站上，解决：对用户的输入做过滤</li>
        <li>csrf 冒充已经登录的用户发送一些恶意的请求</li>
    </ul>

    <p>三次握手</p>
    <ul>
        <li>客户端发送带有SYN标志的数据包 第一次握手-客户端</li>
        <li>服务端发送带有SYN/ACK标志的数据包 第二次握手-服务端</li>
        <li>客户端发送带有ACK标志的数据包 第三次握手-客户端</li>
    </ul>

    <p>四次挥手</p>
    <ul>
        <li>客户端-发送FIN，用来关闭客户端到服务器的数据传送</li>
        <li>服务器-收到FIN，返回一个ACK，确认序号为收到的序号加1</li>
        <li>服务器-关闭与客户端的连接，发送一个FIN给客户端</li>
        <li>客户端-返回ACK报文确认，并将确认序号为收到的序号加1</li>
    </ul>

    <p>http缓存</p>
    <ul>
        <li>HTTP1.0 Pragma, Expires来控制缓存，这两个请求头已经很古老了，但是为了兼容低版本浏览器依然存在，Pragma优先级高于Expires</li>
        <li>Expires控制缓存不太准确，因为这个时间是相对服务器时间而言，如果浏览器的时间跟服务器时间不一致，这就会导致缓存策略不准确，所有有了后来的HTTP 1.1 Cache-Control，优先级排序 Pragma > Cache-Control > Expires</li>
        <li>如果命中强缓存，就返回200，从缓存里面拿资源，如果没有命中强缓存，会带上服务器返回的Last-Modified, ETag，以请求头 If-Modified-Since 和 If-None-Match的形式去请求服务器，看看是否命中协商缓存，如果命中协商缓存就从缓存里面拿，返回304；如果没有命中，就重新返回资源，并且返回200,并且修改Last-Modified, ETag的值</li>
    </ul>


    <p>网站性能优化</p>
    <ul>
        <li>
            控制dns域名解析的个数
        </li>
        <li>
            压缩项目资源，提取公共模块，压缩图片，使用雪碧图
        </li>
        <li>
            缓存资源，加缓存头
        </li>
        <li>
            使用CDN
        </li>
        <li>
            样式放在head，脚本放在dom下面，或者使用无阻塞脚本加载 defer
        </li>
        <li>减少重绘和回流</li>
    </ul>

</body>

</html>